<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <script>
      function findLongestWord(words) {
        var longestWord;
        for (var i = 0; i < words.length; i++) {
          if (!longestWord || words[i].length > longestWord.length) {
            longestWord = words[i];
          }
          // your code here
        }
        console.log("The longest word is '%s', %s chars long!", longestWord, longestWord.length);
        return longestWord;
      }
      data = ['i', 'ki', 'bsi', 'mssadadsadsi'];
      findLongestWord(data);

      function isPalindrome(word) {
        var palindrome = true;
        var half = Math.floor(word.length / 2);
        var leftSide = i;

        for (var i = 0; i < half; i++) {
          var rightSide = word.length - 1 - i;
          // var rightSide = word.length - half + i;

          if (word[i] !== word[rightSide]) {
            palindrome = false;
            break;
          }
        }
        return palindrome;
      }
      var neven = 'neven';
      console.log(isPalindrome(neven));

      function isHalfPalindrom(word) {
        var half = Math.floor(word.length / 2);
        var palinHalf = true;
        for (var i = 0; i < half; i++) {
          var left = i;
          var right = word.length - half + i;
          if (word[left] !== word[right]) {
            return false;
            break;
          }
        }
        return palinHalf;
      }
      var car = 'carcar';
      console.log(isHalfPalindrom(car));

      /*
      Веќе знаеме дека палиндром е збор кој се чита исто и однапред и одназад. Алтернативен начин (можеби поочигледен) да се пристапи на проблемот е самиот збор да се спореди со зборот прочитан од наназад — наместо да правиме for циклус до пола збор и да ги споредуваме карактерите на соодветните позиции лево и десно од средината на зборот, би можеле да изгенерираме целосно нов збор но прочитан наназад: последниот карактер од зборот ќе стане прв карактер од новиот збор, претпоследниот карактер ќе стане втор карактер од новиот збор итн... се до првиот карактер од зборот кој ќе стане последен карактер од новиот збор. Откако ќе го изгенерираме новиот збор, доволно е само да ги споредиме двата збора  word === newWord, ако се исти зборот е палиндром, ако не се исти (не се читаат исто однапред и одназад) тогаш не е палиндром.
      Пробајте сами да ја решите задачата на овој начин. Може да ви биде од помош:
      1. не мора, но веројатно многу ќе си олесните ако направите посебна функција која за даден збор ќе ви го враќа зборот прочитан наопаку. На пр. кога функцијата би ја крстиле reverseWord(word), тогаш кога би ја повикал функцијата со 'blah' ќе ми врати halb — reverseWord('blah') -> 'halb', reverseWord('neven') -> 'neven' итн.
      2. Бидејќи последниот карактер од зборот треба да стане прв карактер од новиот збор, изминувајќи го зборот од наназад кон нанапред може да биде корисно за генерирање на обратно прочитаниот збор for (var i = word.length; i > 0; i--) { ... }
      */
      function reverseWord(word) {
        var revers = '';
        for (var i = word.length - 1; i >= 0; i--) {
          revers += word[i];
          console.log(revers);
        }
        if (revers === word) {
          return word + " is palindrome";
        } else {
          return word + " is not palindrome";
        }
        
      }
      console.log(reverseWord('nessven'));

      // function isPalindrome1(word) {
      //   var palindrome = true;
      //   var half = Math.floor(word.length / 2);
      //   console.log('Is ' + word + ' palindrome?');
      //   for (i = 0; i < half; i++) {
      //     var leftIx = i;
      //     var rightIx = word.length - i - 1;
      //     console.log(
      //       'checking,',
      //       'word[' + leftIx + '](' + word[leftIx] + ')',
      //       ' === ',
      //       'word[' + rightIx + '](' + word[rightIx] + ')',
      //       '?'
      //     );
      //     if (word[i] !== word[word.length - i - 1]) {
      //       palindrome = false;
      //       break;
      //     }
      //   }
      //   if (palindrome) {
      //     console.log('YES', word + ' is palindrome');
      //   } else {
      //     console.log('NO', word + ' is not palindrome');
      //   }
      //   console.log('-----------');
      //   return palindrome;
      // }
      // isPalindrome1("nevenneven");

        function makeWordReversed(word) {
          var reversedWord = '';
          for(var i = word.length - 1; i >=0; i--) {
            reversedWord += word[i];
          }
          return reversedWord;
        }
        console.log(makeWordReversed("skopje"));
        function checkIfPalindromWithFn(word) {
          if(word === makeWordReversed(word)) {
            return word + " is Palindrome both side is equal: " + makeWordReversed(word);
          } else {
            return word + " is NOT Palindrome both side is NOT equal: " + makeWordReversed(word); 
          }
        }
        console.log(checkIfPalindromWithFn("strumica"));
        
    </script>
  </body>
</html>
