<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Object.assign()</title>
  </head>
  <body>
    <h1>Object.assign()</h1>
    <p>
      The Object.assign() method copies all enumerable own properties from one or more source
      objects to a target object. It returns the target object.
    </p>
    <script>
      const target = { a: 1, b: 2 };
      const source = { b: 4, c: 5 };
      const returnedTarget = Object.assign(target, source);
      console.log(target); // expected output: Object { a: 1, b: 4, c: 5 }
      console.log(returnedTarget); // expected output: Object { a: 1, b: 4, c: 5 }
    </script>
    <h3>Syntax</h3>
    <code>Object.assign(target, ...sources)</code>
    <h3>Parameters</h3>
    <p>
      target <br />
      The target object — what to apply the sources’ properties to, which is returned after it is
      modified. <br />
      sources <br />
      The source object(s) — objects containing the properties you want to apply.
    </p>
    <h3>Return value: The target object</h3>
    <h3>Description</h3>
    <p>
      Properties in the target object are overwritten by properties in the sources if they have the
      same key. Later sources' properties overwrite earlier ones. <br />

      The Object.assign() method only copies enumerable and own properties from a source object to a
      target object. It uses [[Get]] on the source and [[Set]] on the target, so it will invoke
      getters and setters. Therefore it assigns properties, versus copying or defining new
      properties. This may make it unsuitable for merging new properties into a prototype if the
      merge sources contain getters. <br />

      For copying property definitions (including their enumerability) into prototypes, use
      Object.getOwnPropertyDescriptor() and Object.defineProperty() instead. <br />

      Both String and Symbol properties are copied. <br />

      In case of an error, for example if a property is non-writable, a TypeError is raised, and the
      target object is changed if any properties are added before the error is raised. <br />

      Note: Object.assign() does not throw on null or undefined sources.
    </p>
    <script>
      // Cloning an object
      const obj1 = { a: 1 };
      const copy = Object.assign({}, obj1);
      console.log(copy); // { a: 1 }

      // Merging objects
      const o1 = { a: 1 };
      const o2 = { b: 2 };
      const o3 = { c: 3 };
      const obj2 = Object.assign(o1, o2, o3);
      console.log(obj2); // { a: 1, b: 2, c: 3 }
      console.log(o1); // { a: 1, b: 2, c: 3 }, target object itself is changed.

      // Merging objects with same properties
      const ob1 = { a: 1, b: 1, c: 1 };
      const ob2 = { b: 2, c: 2 };
      const ob3 = { c: 3 };
      const obj3 = Object.assign({}, ob1, ob2, ob3);
      console.log(obj3); // { a: 1, b: 2, c: 3 }

      // Copying symbol-typed properties
      const ob11 = { a: 1 };
      const ob22 = { [Symbol('foo')]: 2 };
      const obj4 = Object.assign({}, ob11, ob22);
      console.log(obj4); // { a : 1, [Symbol("foo")]: 2 } (cf. bug 1207182 on Firefox)
      Object.getOwnPropertySymbols(obj4); // [Symbol(foo)]

      // Properties on the prototype chain and non-enumerable properties cannot be copied
      const obj5 = Object.create(
        { foo: 1 },
        {
          // foo is on obj's prototype chain.
          bar: {
            value: 2 // bar is a non-enumerable property.
          },
          baz: {
            value: 3,
            enumerable: true // baz is an own enumerable property.
          }
        }
      );
      const copy1 = Object.assign({}, obj5);
      console.log(copy1); // { baz: 3 }

      // Primitives will be wrapped to objects
      const v1 = 'abc';
      const v2 = true;
      const v3 = 10;
      const v4 = Symbol('foo');
      const obj6 = Object.assign({}, v1, null, v2, undefined, v3, v4);
      // Primitives will be wrapped, null and undefined will be ignored.
      // Note, only string wrappers can have own enumerable properties.
      console.log(obj6); // { "0": "a", "1": "b", "2": "c" }

      // Exceptions will interrupt the ongoing copying task
      const target1 = Object.defineProperty({}, 'foo', {
        value: 1,
        writable: false
      }); // target.foo is a read-only property
      //   Object.assign(target1, { bar: 2 }, { foo2: 3, foo: 3, foo3: 3 }, { baz: 4 });
      // TypeError: "foo" is read-only
      // The Exception is thrown when assigning target.foo
      console.log(target1.bar); // 2, the first source was copied successfully.
      console.log(target1.foo2); // 3, the first property of the second source was copied successfully.
      console.log(target1.foo); // 1, exception is thrown here.
      console.log(target1.foo3); // undefined, assign method has finished, foo3 will not be copied.
      console.log(target1.baz); // undefined, the third source will not be copied either

      // Warning for Deep Clone
      //For deep cloning, we need to use alternatives, because Object.assign() copies property values.
      // If the source value is a reference to an object, it only copies the reference value.
      function test() {
        'use strict';

        let obj1 = { a: 0, b: { c: 0 } };
        let obj2 = Object.assign({}, obj1);
        console.log(JSON.stringify(obj2)); // { "a": 0, "b": { "c": 0}}

        obj1.a = 1;
        console.log(JSON.stringify(obj1)); // { "a": 1, "b": { "c": 0}}
        console.log(JSON.stringify(obj2)); // { "a": 0, "b": { "c": 0}}

        obj2.a = 2;
        console.log(JSON.stringify(obj1)); // { "a": 1, "b": { "c": 0}}
        console.log(JSON.stringify(obj2)); // { "a": 2, "b": { "c": 0}}

        obj2.b.c = 3;
        console.log(JSON.stringify(obj1)); // { "a": 1, "b": { "c": 3}}
        console.log(JSON.stringify(obj2)); // { "a": 2, "b": { "c": 3}}

        // Deep Clone
        obj1 = { a: 0, b: { c: 0 } };
        let obj3 = JSON.parse(JSON.stringify(obj1));
        obj1.a = 4;
        obj1.b.c = 4;
        console.log(JSON.stringify(obj3)); // { "a": 0, "b": { "c": 0}}
      }

      test();
    </script>
  </body>
</html>
